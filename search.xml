<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>起始篇</title>
      <link href="/2024/10/07/start/"/>
      <url>/2024/10/07/start/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>  今天（2024.10.7）是我20岁生日，我把这个网站搭建起来，作为我的生日礼物。我也是2字开头的人了，未来的日子，将会是我一生的黄金时代，我希望自己能够，每天充满激情的活着，永远年轻，永远热情地对待任何人和任何事情，永远无畏，永远保持独立思考，永远地学习，永远的做我自己！<br>                        —————— 致我20~30岁的人生</p><blockquote><p>休对故人思故国，且将新火试新茶，诗酒趁年华。</p></blockquote><p><img src="images/9top.jpg" alt="img1"></p>]]></content>
      
      
      <categories>
          
          <category> 碎笔散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题合集</title>
      <link href="/2024/10/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2024/10/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="不存在负权边："><a href="#不存在负权边：" class="headerlink" title="不存在负权边："></a>不存在负权边：</h2><h2 id="1-朴素dijkstra算法"><a href="#1-朴素dijkstra算法" class="headerlink" title="1.朴素dijkstra算法"></a>1.朴素dijkstra算法</h2><p>原题：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d570c81502a29034d2fd6a13d205fa6.png" alt=""></p><p>思路：（依然是贪心的思想）</p><p>1.初始化距离：dis[1]=0，dis[i]=INF（正无穷）</p><p>2.循环n次：</p><pre><code>    找到当前不在s中的dis最小的点（s表示已经确定最短距离的点（可以开一个st数组表示））    假设找到了t这个点，用这个点更新其他所有点的最短距离：            if dis\[x\]&gt;dis\[t\]+wi（这里wi表示边权）</code></pre><p>实例演示：</p><p>代码如下：</p><p>一些注意细节（用//表示）</p><p>c++版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span>  q[N][N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dis[t]&gt;dis[j]))&#123;</span><br><span class="line"><span class="comment">//这里t==-1，其实代表是第一次进入，更新t的值，而后面才开始比较</span></span><br><span class="line"><span class="comment">//t记录的是当前最小的那个节点</span></span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],dis[t]+q[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        q[x][y]=<span class="built_in">min</span>(q[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里储存方式用邻接矩阵，主要是因为用于稠密图。图中可能存在重边和自环，<strong>但所有边权均为正值</strong>。算法复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28n%5E2%29" alt="\mathcal{O}(n^2)"></p><h2 id="2-堆优化的dijkstra"><a href="#2-堆优化的dijkstra" class="headerlink" title="2.堆优化的dijkstra"></a>2.堆优化的dijkstra</h2><blockquote><p>我们思考一下，上述步骤在哪里可以优化：找到当前不在s中的dis最小的点，我们可以用堆进行优化，优化后复杂度为：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mlogn%29" alt="\mathcal{O}(mlogn)">，堆优化，手写堆和优先队列，但是其实在dijkstra中，不需要手写堆，两个复杂度差不多，不如用优先队列方便。并且，此时为稀疏图，用邻接表更好。</p></blockquote><p> 我们用邻接表现在只需要遍历邻接表中头元素连接的，进行更改，每一次取出队列中的最小值即可</p><p>C++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;<span class="comment">//注意开两倍大小</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span><span class="comment">//模板，记下来就好了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver=t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;<span class="comment">//判断是否之前更新过了</span></span><br><span class="line">        st[ver]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[ver]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[ver]+w[i];</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;dis[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//邻接表记得初始化头结点</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如果存在负权边："><a href="#如果存在负权边：" class="headerlink" title="如果存在负权边："></a>如果存在负权边：</h2><h2 id="3-bellman-ford"><a href="#3-bellman-ford" class="headerlink" title="3.bellman-ford"></a>3.bellman-ford</h2><p>（有边数限制）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9afe516391ac442fe5133ac5d101280.png" alt=""></p><p>对于边的存储方式不高。故可以用结构体初始化。</p><p>方式：初始化所有点到源点的距离为∞，把源点到自己的距离设置为0，遍历n次；每次遍历m条边，用每一条边去更新各点到源点的距离。在碰到<strong>限制</strong>了最短路径上边的长度时就只能用bellman_ford了。</p><blockquote><p>for n次<br>for 所有边 a,b,w (松弛操作)<br>dis[b] = min(dis[b],back[a] + w)</p><p>//注意：这里的backup非常重要，为了防止串联：（假设限制只能用1条边）</p><p>如下图：如果出现这样，不用之前的备份，就会出现1-&gt;3最近为2，而不是3，所以要备份一下之前的情况，用之前未更新的情况更新下一个节点。</p></blockquote><p> <img src="https://i-blog.csdnimg.cn/blog_migrate/97fecf6087afc576d5952a54f56131d7.png" alt=""></p><p>c++： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> backup[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,dis,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> e=edge[j];</span><br><span class="line">            dis[e.b]=<span class="built_in">min</span>(dis[e.b],backup[e.a]+e.w);</span><br><span class="line">            <span class="comment">//其实可以利用动态规划</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        edge[i]=&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(dis[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)  <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//可能存在负权边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 时间复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mn%29" alt="\mathcal{O}(mn)"></p><p>例题：<a href="https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/?envType=daily-question&amp;envId=2024-10-03" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> INFTY = INT_MAX / <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(<span class="type">int</span> maxTime, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=passingFees.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(maxTime + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INFTY));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=maxTime;t++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; edge:edges)&#123;</span><br><span class="line">                <span class="type">int</span> i=edge[<span class="number">0</span>],j=edge[<span class="number">1</span>],time=edge[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(time&lt;=t)&#123;</span><br><span class="line">                f[t][i]=<span class="built_in">min</span>(f[t][i],f[t-time][j]+passingFees[i]);</span><br><span class="line">                f[t][j]=<span class="built_in">min</span>(f[t][j],f[t-time][i]+passingFees[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=INFTY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxTime;i++)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,f[i][n<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==INFTY) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-spfa"><a href="#4-spfa" class="headerlink" title="4.spfa"></a>4.spfa</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91478d6ee11f64a2e7aa53c436ee63f5.png" alt=""></p><p>对bellman-ford的优化，不一定每条边都会更新（spfa算法的想法基础）。</p><blockquote><p>dis[b] = min(dis[b],back[a] + w)</p><p>观察这个式子，只有back[a]变小了，我的后继dis[b]才会变小</p><p>所以，我可以用一个队列，在一次变化中，只要有节点变小了，那么就肯定会影响后继节点，就放入队列之中。只要队列不空，就一直类似于bfs一样进行。</p></blockquote><p> 时间复杂度：一般<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28m%29" alt="\mathcal{O}(m)">，最坏<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mn%29" alt="\mathcal{O}(mn)"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与dijkstra非常相似</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-spfa拓展：判断负环"><a href="#5-spfa拓展：判断负环" class="headerlink" title="5.spfa拓展：判断负环"></a>5.spfa拓展：判断负环</h2><blockquote><p>原理：鸽笼原理+三角不等式</p><p>使用spfa算法解决是否存在负环问题</p><p>求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：</p><p>方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环<br>方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环  </p><p>每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：<br>在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。</p><p>1、dist[x] 记录虚拟源点到x的最短距离</p><p>2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] &gt;= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用</p><p>3、若dist[j] &gt; dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步</p><p>注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</p></blockquote><p>引入一个cnt数组，记录每个点经过的边数 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cbb162220a58e90d3b6950f147076b39.png" alt=""></p><p> e.g.</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb14d0090196cca11c44fec962c7109d.png" alt=""></p><p> 但是，如果从1开始到不了负环地方，那么就会出问题，我们的解决方法是一开始把所有的点都放入队列中：（本质就是以每个点为起点做一遍spfa）</p><blockquote><p>for(int i=1;i&lt;=n;i++){<br>    st[i]=1;<br>    q.push(i);<br>}</p></blockquote><p> 需要再cnt基础上更改的地方：</p><blockquote><p> dis[j]=dis[t]+w[i];<br>                cnt[j]=cnt[t]+1;<br>                if(cnt[j]&gt;=n) return true;</p><p>还有对于cnt数组的初始化，还有把spfa变成布尔函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    st[i]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源汇最短路问题："><a href="#多源汇最短路问题：" class="headerlink" title="多源汇最短路问题："></a>多源汇最短路问题：</h2><h2 id="6-Floyd算法"><a href="#6-Floyd算法" class="headerlink" title="6.Floyd算法"></a>6.Floyd算法</h2><p>原题：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad5b1c79035005f56eb9aada883fa579.png" alt=""></p><blockquote><p>原理：基于动态规划：</p><p>d[k,i,j]表示从第i个点出发到达j，只经过1~k个点的最短距离</p><p>状态转移方程：d[k,i,j]=d[k-1,i,k]+d[k-1,k,j]</p><p>发现：k与k-1刚好可以消去这个维度，用一个数组就可以实现</p><p>d[i,j]=d[i,k]+d[k,j]</p></blockquote><p>算法时间复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28n%5E3%29" alt="\mathcal{O}(n^3)"></p><p>具体：</p><blockquote><p>假设节点序号是从1到n。<br>    假设f[0][i][j]是一个n*n的矩阵，第i行第j列代表从i到j的权值，如果i到j有边，那么其值就为ci,j（边ij的权值）。<br>    如果没有边，那么其值就为无穷大。</p><pre><code>f\[k\]\[i\]\[j\]代表（k的取值范围是从1到n），在考虑了从1到k的节点作为中间经过的节点时，从i到j的最短路径的长度。比如，f\[1\]\[i\]\[j\]就代表了，在考虑了1节点作为中间经过的节点时，从i到j的最短路径的长度。  分析可知，f\[1\]\[i\]\[j\]的值无非就是两种情况，而现在需要分析的路径也无非两种情况，i-&gt;j，i-&gt;1-&gt;j：  【1】f\[0\]\[i\]\[j\]：i-&gt;j这种路径的长度，小于，i-&gt;1-&gt;j这种路径的长度  【2】f\[0\]\[i\]\[1\]+f\[0\]\[1\]\[j\]：i-&gt;1-&gt;j这种路径的长度，小于，i-&gt;j这种路径的长度形式化说明如下：  f\[k\]\[i\]\[j\]可以从两种情况转移而来：  【1】从f\[k−1\]\[i\]\[j\]转移而来，表示i到j的最短路径不经过k这个节点  【2】从f\[k−1\]\[i\]\[k\]+f\[k−1\]\[k\]\[j\]转移而来，表示i到j的最短路径经过k这个节点总结就是：**f\[k\]\[i\]\[j\]=min(f\[k−1\]\[i\]\[j\],f\[k−1\]\[i\]\[k\]+f\[k−1\]\[k\]\[j\])**  从总结上来看，发现f\[k\]只可能与f\[k−1\]有关。</code></pre></blockquote><p>初始化与读入邻接矩阵（存在自环和重边的时候）：</p><blockquote><p>for (int i = 1; i &lt;= n; i ++ )<br>    for (int j = 1; j &lt;= n; j ++ )<br>        if (i == j) d[i][j] = 0;<br>        else d[i][j] = INF;</p><p>while (m — )<br>{<br>    int a, b, c;<br>    scanf(“%d%d%d”, &amp;a, &amp;b, &amp;c);<br>    d[a][b] = min(d[a][b], c);<br>}</p></blockquote><p>c++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        <span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp与java常用的stl总结</title>
      <link href="/2024/10/07/cpp%E4%B8%8Ejava%E5%B8%B8%E7%94%A8%E7%9A%84stl%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/07/cpp%E4%B8%8Ejava%E5%B8%B8%E7%94%A8%E7%9A%84stl%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组（vector-ArrayList）"><a href="#1-数组（vector-ArrayList）" class="headerlink" title="1.数组（vector/ArrayList）"></a>1.数组（vector/ArrayList）</h2><h3 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><blockquote><p>vector<int> v;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作v.push_back(); //清空操作v.clear();  //求长度操作int len=v.size();v.empty();//判断是否为空 //删除字符串操作v.pop_back(); // 删除向量末尾的元素v.erase(v.begin() + n); // 删除索引为n的元素 //离散化操作+去重sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end()); *在前面还有加上查找：int find(int x)&#123;    return lower_bound(v.begin(), v.end(), x) - v.begin();&#125;  //翻转函数v.reverse(v.begin(),v.end()); //查找函数 用的较少auto it = find(v.begin(), v.end(), target);if (it != v.end()) &#123;    cout &lt;&lt; distance(v.begin(), it) &lt;&lt; endl;&#125;  //自定义排序函数 lambda表达式sort(v.begin(), v.end(), [](int a, int b) &#123;        return a &gt; b; // 左升序 右降序    &#125;); 也可以：bool cmp(int x,int y)&#123;    return x&gt;y;  //降序&#125;bool cmp(int x,int y)&#123;    return x&lt;y;//升序&#125; 还可以：sort(v.begin(), v.end(),greater&lt;int&gt;();//降序sort(v.begin(),v.end(),less&lt;int&gt;());//升序</span></span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><blockquote><p> list<int> l;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//插入l.push_back(1); //复制l.assign(l1.begin(),l1.end()); //交换l.swap(l1); //大小l.size();l.empty();//判空</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/6acd28357f78439bab81541062e05662.png" alt=""> 排序：</p><p>l.sort();</p><p>第一个元素：l.front();</p><p>最后一个元素：l.back();</p><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h4><blockquote><p><strong>List list = new ArrayList();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素list.add(n);list.add(index, n);// 在指定位置插入元素list.set(index,n);// 更新元素// 获取元素list.get(index); // 删除元素list.remove(n);list.remove(index);// 删除指定位置的元素 // 检查元素是否存在list.contains(n);  // 获取ArrayList的大小list.size(); // 清空ArrayListlist.clear(); // 遍历ArrayListfor (int n : list) &#123;    System.out.println(n);&#125; // 使用迭代器遍历Iterator&lt;Interger&gt; iterator = list.iterator();while (iterator.hasNext()) &#123;    int n = iterator.next();    System.out.println(n);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList（双向链表）"><a href="#LinkedList（双向链表）" class="headerlink" title="LinkedList（双向链表）"></a>LinkedList（双向链表）</h4><blockquote><p>LinkedList<String> list = new LinkedList<String>();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;<span class="comment">// 创建一个空的LinkedListLinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();// 添加元素到列表末尾list.add(&quot;Apple&quot;);// 添加元素到列表开头list.addFirst(&quot;Banana&quot;);// 在指定位置插入元素list.add(1, &quot;Cherry&quot;);// 获取第一个元素String first = list.getFirst();// 获取最后一个元素String last = list.getLast();// 删除第一个元素String removedFirst = list.removeFirst();// 删除最后一个元素String removedLast = list.removeLast();// 删除指定位置的元素String removed = list.remove(1);// 检查元素是否存在boolean contains = list.contains(&quot;Cherry&quot;);// 获取LinkedList的大小int size = list.size();// 清空LinkedListlist.clear();// 遍历LinkedListfor (String fruit : list) &#123;    System.out.println(fruit);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="HashSet（不重复元素的集合）"><a href="#HashSet（不重复元素的集合）" class="headerlink" title="HashSet（不重复元素的集合）"></a>HashSet（不重复元素的集合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素set.add(n); // 删除元素set.remove(n); // 检查元素是否存在boolean contains = set.contains(n); // 获取HashSet的大小int size = set.size(); // 清空HashSetset.clear(); // 遍历HashSetfor (String fruit : set) &#123;    System.out.println(fruit);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2.Map"></a>2.Map</h2><h3 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote><p>map<E,E> m;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map中使用较多1，存储  2，遍历  3，排序 4，查找 //存储,m[key]=value；m[E]=E; //查找auto it = m.find(n); // 查找key为n的元素if (it != m.end()) &#123;    cout&lt;&lt;it-&gt;second&lt;&lt;endl;//输出value值&#125; //删除m.erase(n); // 删除key为n的元素m.erase(m.begin()); // 删除映射中的第一个元素 //统计key个数m.count(&quot;key&quot;);//遍历for(auto k:m) &#123;    cout&lt;&lt;k.first&lt;&lt;&#x27; &#x27;&lt;&lt;k.second&lt;&lt;endl;&#125; //排序 默认按照key值升序排序//在声明的时候添加:greater&lt;int&gt;  就变成降序排序map&lt;E,E,greater&lt;E&gt;&gt; //默认按照key降序排序 //自定义排序主要用于按照value进行排序的情况bool cmp(const pair&lt;int, string&gt;&amp; a, const pair&lt;int, string&gt;&amp; b) &#123;// 自定义比较函数，用于比较map的value    return a.second &lt; b.second; // 按照value的字典序排序&#125; vector&lt;pair&lt;E, E&gt;&gt; v(m.begin(), m.end());//直接把map当作pair类型存到vector中，key-&gt;first  value-seond sort(v.begin(),v.end(),cmp);//现在直接输出v即可/*简易测试代码    m[0]=&quot;1&quot;;    m[2]=&quot;11&quot;;    m[1]=&quot;22&quot;;    vector&lt;PII&gt; v(m.begin(),m.end());    sort(v.begin(),v.end(),cmp);    for(auto k:v) cout&lt;&lt;k.first&lt;&lt;&#x27; &#x27;; //输出的是key     输出:0 2 1  正常输出应该是默认升序0 1 2*/</span></span><br></pre></td></tr></table></figure><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><blockquote><p>unordered_map<int,int> data; </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入：    <span class="comment">// 方式1: 使用下标运算符[]，如果键不存在，则插入新元素    data[&quot;apple&quot;] = 5;    // 方式2: 使用insert()函数插入一个pair类型的对象    data.insert(pair&lt;string, int&gt;(&quot;banana&quot;, 3));    // 方式3: 使用insert()函数插入一个make_pair()生成的键值对    data.insert(make_pair(&quot;orange&quot;, 7));    // 方式4: 使用insert()函数插入一个初始化列表表示的键值对    data.insert(&#123;&quot;grape&quot;, 2&#125;);    // 方式5: 使用emplace()函数直接构造键值对并插入    data.emplace(&quot;pear&quot;, 4); //从容器中删除。//keydata.erase(&quot;orange&quot;);//迭代器auto it = data.find(&quot;grape&quot;);if (it != data.end()) &#123;    data.erase(it);&#125; clear()：清除容器中的所有元素。 //通过key查找元素auto it = data.find(&quot;apple&quot;);if (it != data.end()) &#123;    // 找到元素，进行操作&#125;//判断key是否存在if (data.count(&quot;banana&quot;)) &#123;    // 键存在&#125; 遍历：for (const auto&amp; pair : data) &#123;    std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;&#125;for (auto it = data.begin(); it != data.end(); ++it) &#123;    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><h4 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h4><blockquote><p><strong>Map<String, Integer> map = new HashMap<String, Integer>();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加键值对map.put(n, m); // 获取值map.get(n); // 检查键是否存在map.containsKey(n);//如果有值就用原来的值  没有赋新值(记不得那个操作了)map.containsKey(n) ? map.put(n,map.get(n)+x) : m;  //三元运算符实现 // 删除键值对map.remove(n);map.clear();// 清空HashMap // 获取HashMap的大小map.size(); // 遍历HashMap的键for (String key : map.keySet()) &#123;    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + map.get(key));&#125; // 遍历HashMap的条目for (HashMap.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());&#125;</span></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素set.add(n); // 删除元素set.remove(n); // 检查元素是否存在boolean contains = set.contains(n); // 获取HashSet的大小int size = set.size(); // 清空HashSetset.clear(); // 遍历HashSetfor (String fruit : set) &#123;    System.out.println(fruit);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-栈与队列"><a href="#3-栈与队列" class="headerlink" title="3.栈与队列"></a>3.栈与队列</h2><h3 id="C-：-1"><a href="#C-：-1" class="headerlink" title="C++："></a>C++：</h3><h4 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h4><blockquote><p>queue<int> q</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队q.push(n);    //获取对头q.front();q.back();//获取队尾 //对头出队q.pop(); //大小q.size();q.empty();//非空判断</span></span><br></pre></td></tr></table></figure><h4 id="优先队列-priority-queue：（插入一个数就排序的队列）"><a href="#优先队列-priority-queue：（插入一个数就排序的队列）" class="headerlink" title="优先队列 priority_queue：（插入一个数就排序的队列）"></a>优先队列 priority_queue：（插入一个数就排序的队列）</h4><blockquote><p> priority_queue<int, vector<int>, less<int>/greater<int>&gt; pq;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队pq.push(n);    //获取对头pq.top();pq.back();//获取队尾 //对头出队pq.pop(); //大小pq.size();pq.empty();//非空判断</span></span><br></pre></td></tr></table></figure><h4 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h4><blockquote><p>stack<int> s;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈s.push(); //访问s.top();s.pop(); //出栈 //大小s.size();s.empty();//非空判断</span></span><br></pre></td></tr></table></figure><h3 id="java："><a href="#java：" class="headerlink" title="java："></a>java：</h3><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><blockquote><p><strong>Queue queue = new LinkedList&lt;&gt;();</strong></p><p>在Java中，<code>Queue</code> 是一个先进先出（FIFO）的数据结构，它通过接口来实现，常用的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作queue.offer(1); // 出队操作int head = queue.poll(); // 移除并返回队头元素 // 查看队头元素（不出队）int peek = queue.peek(); // 获取队头元素（如果队列为空，则抛出NoSuchElementException）int element = queue.element(); // 获取Queue的大小queue.size(); // 检查Queue是否为空queue.isEmpty(); // 清空Queuequeue.clear(); // 遍历Queuewhile (!queue.isEmpty()) &#123;    System.out.println(queue.poll());&#125; // 使用迭代器遍历Iterator&lt;Integer&gt; iterator = queue.iterator();while (iterator.hasNext()) &#123;    Integer element = iterator.next();    System.out.println(element);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="优先队列："><a href="#优先队列：" class="headerlink" title="优先队列："></a>优先队列：</h4><blockquote><p>PriorityQueue<Integer> queue = new PriorityQueue<Integer>(10, new Comparator<Integer>() {<br>            public int compare(Integer a, Integer b) {<br>                return a - b; //if a&gt;b 则交换，so这是递增序列<br>            }<br>        });</p><p>PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k+1,Comparator.reverseOrder());</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作queue.offer(1); // 出队操作int head = queue.poll(); // 移除并返回队头元素 // // 获取队头元素（不出队）int peek = queue.peek();  // 获取Queue的大小queue.size(); // 检查Queue是否为空queue.isEmpty(); // 清空Queuequeue.clear(); // 遍历Queuewhile (!queue.isEmpty()) &#123;    System.out.println(queue.poll());&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><blockquote><p><strong>Stack stack = new Stack&lt;&gt;();</strong></p><p>在Java中，<code>Stack</code> 是一个后进先出（LIFO）的数据结构，它是通过扩展 <code>Vector</code> 类来实现的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈操作stack.push(1); // 出栈操作int top = stack.pop(); // 移除并返回栈顶元素 // 查看栈顶元素（不出栈）int peek = stack.peek(); // 搜索元素，返回元素在栈中的位置（距离栈顶的距离）int index = stack.search(n); // 获取Stack的大小int size = stack.size(); // 检查Stack是否为空boolean isEmpty = stack.isEmpty(); // 清空Stackstack.clear(); // 遍历Stackwhile (!stack.isEmpty()) &#123;    System.out.println(stack.pop());&#125; // 使用迭代器遍历Iterator&lt;Integer&gt; iterator = stack.iterator();while (iterator.hasNext()) &#123;    Integer element = iterator.next();    System.out.println(element);&#125;</span></span><br></pre></td></tr></table></figure><p>一个小技巧：</p>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/10/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/10/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h2><p><strong>线段树=分治法+二叉树结构+Lazy—Tag技术。</strong></p><p>线段树样式[1,10]：</p><p><img src="https://i-blog.csdnimg.cn/direct/c4ceccc5138f472fb6869dd7b9eda0ff.jpeg" alt=""></p><h2 id="线段树常用操作："><a href="#线段树常用操作：" class="headerlink" title="线段树常用操作："></a>线段树常用操作：</h2><blockquote><p>1.pushup（从下往上）</p><p>1.1(hard) pushdown（懒标记，后面写）</p><p>2.build（建立）</p><p>3.modify（修改）</p><p>4.query(查询)</p></blockquote><p>先来看：</p><h3 id="线段树的build"><a href="#线段树的build" class="headerlink" title="线段树的build"></a>线段树的build</h3><p>前提结论：当做二叉树看：对于编号为x的点：</p><p>父节点：向下取整（x/2），左儿子：2x，右儿子：2x+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//u表示当前线段树一段区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;<span class="comment">//意味着到达了叶节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//等于2*u</span></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);<span class="comment">//等于2*u+1</span></span><br><span class="line">    <span class="comment">//一般后面接上pushup(u)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询，修改"><a href="#查询，修改" class="headerlink" title="查询，修改"></a>查询，修改</h3><p>原理：都是依次递归，比较简单，详细见后面例题。</p><p>补充：查询最小值（图1），查询区间和（图2）构造的线段树</p><p>图1</p><p><img src="https://i-blog.csdnimg.cn/direct/062c469ee45f47bfb923c25acfb5431b.jpeg" alt=""></p><p>图2</p><p><img src="https://i-blog.csdnimg.cn/direct/8a8942e294ba442fae85db5a0ffc3906.jpeg" alt=""></p><h3 id="线段树要开4倍空间"><a href="#线段树要开4倍空间" class="headerlink" title="线段树要开4倍空间"></a>线段树要开4倍空间</h3><p><a href="https://blog.csdn.net/qq_43803508/article/details/97501894?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172077162316800213020125%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172077162316800213020125&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-97501894-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%9B%9B%E5%80%8D&amp;spm=1018.2226.3001.4187" title="链接1">链接1</a></p><p><a href="https://blog.csdn.net/smoggyxhdz/article/details/78895672" title="链接2">链接2</a></p><h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p><img src="https://i-blog.csdnimg.cn/direct/b3059411c73541dc9f85ff1aa1c6f37b.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> v;  <span class="comment">// 区间[l, r]中的最大值</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span>  <span class="comment">// 由子节点的信息，来计算父节点的信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;   <span class="comment">// 树中节点，已经被完全包含在[l, r]中了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) v = <span class="built_in">max</span>(v, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;p);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>, n - x + <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, ((LL)last + x) % p);</span><br><span class="line">            n ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查询区间最大连续子段和，单点修改"><a href="#查询区间最大连续子段和，单点修改" class="headerlink" title="查询区间最大连续子段和，单点修改"></a>查询区间最大连续子段和，单点修改</h2><p><img src="https://i-blog.csdnimg.cn/direct/7a6d8bd767594fd3b278263c5ed859dd.png" alt=""></p><blockquote><p><img src="https://i-blog.csdnimg.cn/direct/6d8d130358184d258fb10dd78c2d3184.png" alt=""></p></blockquote><p> 如何知道上面的东西，我们推导一下，首先我们要求一个区间内最大连续子段和。</p><p><img src="https://i-blog.csdnimg.cn/direct/ecec48e31d2c48b3b75e7b3bcc543bc8.png" alt=""></p><p>那么根据上述操作我们发现我们可以求出tmax，但是引入了lmax与rmax，我们再想办法解决这个问题。</p><p><img src="https://i-blog.csdnimg.cn/direct/e3b0f97492304dd6bcd1f32fd8c5a055.png" alt=""></p><p> 而引入的sum只需要求出区间和就可以。</p><p>则：pushup代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, lmax, rmax, tmax;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><h3 id="1-Lazy-Tag方法，区间修改"><a href="#1-Lazy-Tag方法，区间修改" class="headerlink" title="1.Lazy-Tag方法，区间修改"></a>1.Lazy-Tag方法，区间修改</h3><blockquote><p>对于区间修改很容易想到解决办法，还是利用线段树的特征：<br>线段树的节点tree[i]记录了区间i的值,那么可以再定义一个tag[i]，用它统一记录区间i的修改，而不是一个个地修改区间内的每个元素，这个方法称为Lazy-Tag(懒惰标记或延迟标记)。</p></blockquote><p>使用Lazy-Tag方法时，若修改的是一个线段区间，就只对这个线段区间进行整体上的<br>修改，其内部每个元素的内容先不做修改，只有当这个线段区间的一致性被破坏时，才把变<br>化值传递给下一层的子区间。每次区间修改的复杂度为O(log2n),一共m次操作，总复杂<br>度为O(mlog2n)。区间i的Lazy操作，用tag[i]记录。</p><h2 id="2-push-down"><a href="#2-push-down" class="headerlink" title="2.push_down"></a>2.push_down</h2><p>传递函数push_down()是处理Lazy-Tag的一个技巧。在进行多次区间修改时，一个<br>节点需要记录多个区间修改，而这些区间修改往往有冲突。所以，Lazy-Tag的主要操作是解决多<br>次区间修改，用push_down()函数完成。首先检查节点p的tag[p],如果有值，说明前面做<br>区间修改时给p打了tag标记，接下来就把tag[p]传给左右子树，然后把tag[p]清零。</p><p>上述操作图示简述：</p><blockquote><p>Struct Node{</p><p>int l,r;</p><p>int sum,add;</p><p>}</p><p>Add-&gt;懒标记</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/fc0069d2261f41b9b27417c635c181bf.png" alt=""></p><p> push_down操作：</p><p>对于节点：root，要将root.add把它pushdown一下：</p><blockquote><p>left.add+=root.add</p><p>left.sum+=(left.r-left.l+1)*root.add</p><p>right.add+=root.add</p><p>right.sum+=(right.r-right.l+1)*root.add</p><p>root.add=0</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/f08de53ace964baab724426bec6ef2b0.png" alt=""></p><p><a href="https://www.luogu.com.cn/problem/P3372" title="【模板】线段树 1 - 洛谷">【模板】线段树 1 - 洛谷</a></p><p>其他同上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (LL)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (LL)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 一定要分裂</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h2><p><a href="https://www.luogu.com.cn/problem/P5490" title="【模板】扫描线 - 洛谷">【模板】扫描线 - 洛谷</a></p><p> 扫描线：</p><h4 id="面积并"><a href="#面积并" class="headerlink" title="面积并"></a>面积并</h4><p>要求两个矩形叠加后的面积和：</p><p><img src="https://i-blog.csdnimg.cn/direct/a21d40eedece44848fd3ab78c8688c91.png" alt=""></p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>现在假设，扫描线每次会在碰到竖边的时候停下来，如图。</p><p><img src="https://i-blog.csdnimg.cn/direct/251b5590f2184e3d9f00b91a39e43d7b.png" alt=""></p><h4 id="为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。"><a href="#为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。" class="headerlink" title="为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。"></a>为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。</h4><p>然后把所有的横边按照x坐标升序排序。这样，对于每个矩形，扫描线总是会<strong>先碰到左边，然后再碰到右边</strong>。那么就能保证扫描线所截的长度永远非负了。</p><p>这样操作以后，就可以和<strong>线段树</strong>扯上关系。先把所有端点在y轴上离散化（其实就是把所有点的横坐标存到里，然后升序排个序，最后去重）。</p><p><img src="https://i-blog.csdnimg.cn/direct/e3658bbac8cd4dacb96735ec9041874b.png" alt=""><strong>为什么会想到用线段树，</strong>我们来看一下面积表达式：</p><p><img src="https://latex.csdn.net/eq?%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dx%5B0%5D%5Ccdot%20l_i" alt="\sum_{i=1}^{n}x[0]\cdot l_i"></p><p>我们发现x[0]好求，就是想爱你吨数根节点，关键是<img src="https://latex.csdn.net/eq?l_i" alt="l_i">，也就是<img src="https://latex.csdn.net/eq?%5CDelta%20x_i" alt="\Delta x_i">所对应的矩形另一条边的长度。对于一个矩形，其左边权值为1，右边权值为−1。那么我们发现只要定义一个len表示长度，cnt表示次数，只要cnt激活后，就把len激活到<img src="https://latex.csdn.net/eq?l_i" alt="l_i">。</p><p>e.g.蓝色表示第一次更新，紫色表示第二次更新，绿色表示第三次更新。</p><p>我们发现主要求<img src="https://latex.csdn.net/eq?l_i" alt="l_i">，而每次激活的区域刚好可以用线段树去统计，很方便。（即区间查询）</p><p><img src="https://i-blog.csdnimg.cn/direct/eec576e1283848b29814e77656662f07.png" alt=""></p><p>（注意离散化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//-1,1</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Seg&amp;t) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];<span class="comment">//区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll len,cnt;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), x) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)&#123;</span><br><span class="line">        tr[u].len=ys[tr[u].r<span class="number">+1</span>]-ys[tr[u].l];<span class="comment">//离散化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l != tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].cnt+=d;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>,l,r,d);<span class="comment">//左边存在点</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r,d);<span class="comment">//右边存在点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//cnt</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">        seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y1);</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line">    ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(seg,seg+j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].tag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒标记迭代"><a href="#懒标记迭代" class="headerlink" title="懒标记迭代"></a>懒标记迭代</h2><p><a href="https://www.luogu.com.cn/problem/P3373" title="【模板】线段树 2 - 洛谷">【模板】线段树 2 - 洛谷</a></p><p>与之前不同，这里这么定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p> 重点步骤：</p><p>推公式：</p><p> <img src="https://i-blog.csdnimg.cn/direct/a8284f38938e4ba2b8013b05857d67dc.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t,<span class="type">int</span> add,<span class="type">int</span> mul)</span></span>&#123;<span class="comment">//懒标记叠加</span></span><br><span class="line">    t.sum = ((ll)t.sum * mul + (ll)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    t.mul = (ll)t.mul * mul % p;</span><br><span class="line">    t.add = ((ll)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,p,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t,<span class="type">int</span> add,<span class="type">int</span> mul)</span></span>&#123;<span class="comment">//懒标记叠加</span></span><br><span class="line">    t.sum = ((ll)t.sum * mul + (ll)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    t.mul = (ll)t.mul * mul % p;</span><br><span class="line">    t.add = ((ll)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,w[r],<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add,<span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(tr[u], add, mul);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="type">int</span> x,y,k;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,y,<span class="number">0</span>,k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,y,k,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/10/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>持续更新</strong></p></blockquote><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><h3 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h3><p><img src="https://i-blog.csdnimg.cn/direct/7af3aa22023c4a58aafeaf5d32fcb659.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/7a67b415f7d94b7abd7504062e12a7f1.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r,c;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> w[N][N],res[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">               res[i][j]=<span class="built_in">max</span>(res[i<span class="number">-1</span>][j]+w[i][j],res[i][j<span class="number">-1</span>]+w[i][j]);</span><br><span class="line"></span><br><span class="line">       cout&lt;&lt;res[r][c]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h3><p><img src="https://i-blog.csdnimg.cn/direct/546cb151875743aeaf9aa397c9791d30.png" alt=""></p><p>注意min的问题一定要考虑边界问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e9;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> w[N][N],res[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line">            </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)  res[i][j]=w[i][j];<span class="comment">//不能直接写res[1][1]=w[1][1],因为for循环里面有res[1][1]=INF;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            res[i][j]=INF;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>) res[i][j]=<span class="built_in">min</span>(res[i][j],res[i<span class="number">-1</span>][j]+w[i][j]);<span class="comment">// 只有不在第一行的时候，才可以从上面过来</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">1</span>) res[i][j]=<span class="built_in">min</span>(res[i][j],res[i][j<span class="number">-1</span>]+w[i][j]);<span class="comment">// 只有不在第一列的时候，才可以从左面过来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res[r][r]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方格取数（洛谷）"><a href="#方格取数（洛谷）" class="headerlink" title="方格取数（洛谷）"></a>方格取数（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P1004" title="[NOIP2000 提高组] 方格取数 - 洛谷">[NOIP2000 提高组] 方格取数 - 洛谷</a></p><p><img src="https://i-blog.csdnimg.cn/direct/c2a0bb9f4af6499c8f30ad928e7b0b16.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/f2d1b3bdbe9c46ab8d70d05c6e93dda6.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x,y,r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        w[x][y]=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n+n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n;i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">1</span>;i2&lt;=n;i2++)&#123;</span><br><span class="line">                <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">                <span class="keyword">if</span>(j1&gt;=<span class="number">1</span>&amp;&amp;j1&lt;=n&amp;&amp;j2&gt;=<span class="number">1</span>&amp;&amp;j2&lt;=n)&#123;</span><br><span class="line">                    <span class="type">int</span> t=w[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n + n][n][n]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="传纸条（洛谷）"><a href="#传纸条（洛谷）" class="headerlink" title="传纸条（洛谷）"></a>传纸条（洛谷）</h3><p> <a href="https://www.luogu.com.cn/problem/P1006" title="[NOIP2008 提高组] 传纸条 - 洛谷">[NOIP2008 提高组] 传纸条 - 洛谷</a></p><p>注意：此题是正方形，所以i1,i2的限制只有1&lt;=i1,i2&lt;=n。下面一道题变成长方形(m*n)的时候，就会有限制：</p><p><img src="https://latex.csdn.net/eq?1%5Cleqslant%20i1%20%5Cleqslant%20n%20%5Cquad%201%5Cleqslant%20k-i1%5Cleqslant%20m%5CRightarrow%20%5Cquad%20%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%201%5Cleqslant%20i1%20%5Cleqslant%20n%5C%5C%20k-m%5Cleqslant%20i1%20%5Cleqslant%20k-1%20%5Cend%7Bmatrix%7D%5Cright." alt="1\leqslant i1 \leqslant n \quad 1\leqslant k-i1\leqslant m\Rightarrow \quad \left\{\begin{matrix} 1\leqslant i1 \leqslant n\\ k-m\leqslant i1 \leqslant k-1 \end{matrix}\right."></p><p><img src="https://latex.csdn.net/eq?summary%20%5CRightarrow%20max%281%2Ck-m%29%5Cleqslant%20i1%20%5Cleqslant%20min%28n%2Ck-1%29" alt="summary \Rightarrow max(1,k-m)\leqslant i1 \leqslant min(n,k-1)"></p><p>同理，i2范围与i1一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N][N];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=m+n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="built_in">max</span>(<span class="number">1</span>,k-n);i1&lt;=<span class="built_in">min</span>(k<span class="number">-1</span>,m);i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="built_in">max</span>(<span class="number">1</span>,k-n);i2&lt;=<span class="built_in">min</span>(k<span class="number">-1</span>,m);i2++)&#123;</span><br><span class="line">                <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">                <span class="type">int</span> t=w[i1][j1];</span><br><span class="line">                <span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line">                <span class="type">int</span> &amp;x=f[k][i1][i2];</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2<span class="number">-1</span>]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2<span class="number">-1</span>]+t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m+n][m][m];<span class="comment">//注意两个路线横坐标都是n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h2><h3 id="（-）最长上升子序列（洛谷）-amp-最长递增子序列（leetcode）"><a href="#（-）最长上升子序列（洛谷）-amp-最长递增子序列（leetcode）" class="headerlink" title="（*****）最长上升子序列（洛谷）&amp;最长递增子序列（leetcode）"></a>（*****）最长上升子序列（洛谷）&amp;最长递增子序列（leetcode）</h3><p><a href="https://www.luogu.com.cn/problem/B3637" title="最长上升子序列 - 洛谷">最长上升子序列 - 洛谷</a></p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" title="300.最长递增子序列">300.最长递增子序列</a></p><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p><p>状态转移方程：</p><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p><p><img src="https://i-blog.csdnimg.cn/direct/b26f61b3a65d4e4fb5c88c9b65533cdd.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/00230658077d4e9397751278591a94a1.png" alt=""></p><p> 洛谷题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode674-最长连续递增序列"><a href="#leetcode674-最长连续递增序列" class="headerlink" title="leetcode674. 最长连续递增序列"></a>leetcode674. 最长连续递增序列</h3><p> <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/" title="674. 最长连续递增序列">674. 最长连续递增序列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i]=dp[i<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode718-最长重复子数组"><a href="#leetcode718-最长重复子数组" class="headerlink" title="leetcode718. 最长重复子数组"></a>leetcode718. 最长重复子数组</h3><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/" title="最长重复子数组">最长重复子数组</a></p><blockquote><p>定义dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。</p><p>确定递推公式：</p><p>根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，<strong>dp[i][j] = dp[i - 1][j - 1] + 1;</strong></p><p><strong>例如：【1,2,3,4】与【9,1,2,3】</strong></p><p><strong>当i=1，j=2时候，相等，由于连续，那么i退一格，j退一格，刚好就是dp【i】【j】的更新。</strong></p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p></blockquote><p>这里代码用：i-1是为了方便，不想初始化，直接把0视为无用位，从1开始推。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span> (nums<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums<span class="number">1.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums<span class="number">2.</span><span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（-）leetcode最长公共子序列（LCS）-amp-最长上升子序列-洛谷"><a href="#（-）leetcode最长公共子序列（LCS）-amp-最长上升子序列-洛谷" class="headerlink" title="（*****）leetcode最长公共子序列（LCS）  &amp;最长上升子序列 - 洛谷"></a>（*****）leetcode最长公共子序列（LCS）  &amp;最长上升子序列 - 洛谷</h3><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/" title="leetcode最长公共子序列">leetcode最长公共子序列</a></p><blockquote><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;</p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</p><p>找子问题，</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/c32ead5d55ba4e2fa63d42d4c8083f8c.png" alt=""></p><blockquote><p> ++++++++++其实就是x与y的问题，我们已知x,y前面的状态确定：</p><p>If x==y    </p><p>那么就是在原来的基础上（i-1,j-1)</p><p>基础上+1即可</p><p>Else(x!=y) 那么就是说我既然是对x,y的讨论</p><p>那么直接看我不要x，还是不要y那个子串</p><p>更长，那么我就让这个更长的记录到这里</p><p>（我们默认了前面状态已知，只需要考虑</p><p>x,y，为什么不考虑把x，y都舍弃，因为</p><p>已经包含在内了（看dp数组的定义）</p></blockquote><p> 举个例子：</p><p> *（dp[2][4],dp[3][3]在之前已经求过了）</p><p><img src="https://i-blog.csdnimg.cn/direct/dbec674c00114527b46ec6332f547d90.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=text<span class="number">1.</span><span class="built_in">size</span>(),n2=text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在洛谷：</p><p><a href="https://www.luogu.com.cn/problem/B3637" title="最长上升子序列 - 洛谷">最长上升子序列 - 洛谷</a></p><p>用刚刚的思路，会卡你：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5000</span>],b[<span class="number">5000</span>],f[<span class="number">5000</span>][<span class="number">5000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i==<span class="number">0</span>)||(j==<span class="number">0</span>)) &#123;</span><br><span class="line">      f[i][j]=<span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      <span class="keyword">if</span> (a[i]==b[j]) f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i]!=b[j]) f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/6124c9d7d33b4f96873c2583634abc63.png" alt=""></p><p>用优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>],b[<span class="number">100001</span>],map[<span class="number">100001</span>],f[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);map[a[i]]=i;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);f[i]=<span class="number">0x7fffffff</span>;&#125;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=len,mid;</span><br><span class="line"><span class="keyword">if</span>(map[b[i]]&gt;f[len])f[++len]=map[b[i]];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[mid]&gt;map[b[i]])r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid<span class="number">+1</span>; </span><br><span class="line">&#125;</span><br><span class="line">f[l]=<span class="built_in">min</span>(map[b[i]],f[l]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/06a5f48006ad40619df8d146e3c88ce4.png" alt=""></p><h3 id="leetcode1035-不相交的线"><a href="#leetcode1035-不相交的线" class="headerlink" title="leetcode1035. 不相交的线"></a>leetcode1035. 不相交的线</h3><p><a href="https://leetcode.cn/problems/uncrossed-lines/description/" title="1035. 不相交的线">1035. 不相交的线</a></p><p>仔细分析此题，发现与上面那道题一模一样，就是求两个数组的LCS。</p><p>代码一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=nums<span class="number">1.</span><span class="built_in">size</span>(),n2=nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>]==nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode53-最大子数组和"><a href="#leetcode53-最大子数组和" class="headerlink" title="leetcode53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/" title="leetcode53. 最大子数组和">leetcode53. 最大子数组和</a></h3><p> <a href="https://leetcode.cn/problems/maximum-subarray/description/" title="leetcode53. 最大子数组和">leetcode53. 最大子数组和</a></p><p><strong>dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]</strong>。</p><p>dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>遍历所以的dp找到最大的输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode392-判断子序列"><a href="#leetcode392-判断子序列" class="headerlink" title="leetcode392. 判断子序列"></a>leetcode392. 判断子序列</h3><p><a href="https://leetcode.cn/problems/is-subsequence/description/" title="392. 判断子序列">392. 判断子序列</a></p><p>与LCS一模一样，就是判断一下是否等于s的长度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=s.<span class="built_in">size</span>(),n2=t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[n1][n2]==n1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有更简洁的写法：</p><p>直接扫描string t，然后相同就++i，如果有i==t.size()，那么就有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == c &amp;&amp; ++i == s.<span class="built_in">length</span>()) &#123; <span class="comment">// 所有字符匹配完毕</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// s 是 t 的子序列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode115-不同的子序列"><a href="#leetcode115-不同的子序列" class="headerlink" title="leetcode115. 不同的子序列"></a>leetcode115. 不同的子序列</h3><p><a href="https://leetcode.cn/problems/distinct-subsequences/description/" title="leetcode115. 不同的子序列">leetcode115. 不同的子序列</a></p><blockquote><p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul></blockquote><p> s[i - 1] 与 t[j - 1]相等</p><p><img src="https://i-blog.csdnimg.cn/direct/5c931c26aa4a43bb83da5b3338b84f0b.png" alt=""></p><p>s[i - 1] 与 t[j - 1] 不相等：</p><p>dp[i][j] = dp[i - 1][j];</p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode583-两个字符串的删除操作"><a href="#leetcode583-两个字符串的删除操作" class="headerlink" title="leetcode583. 两个字符串的删除操作"></a>leetcode583. 两个字符串的删除操作</h3><p> <a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/" title="leetcode583. 两个字符串的删除操作">leetcode583. 两个字符串的删除操作</a></p><blockquote><p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><p><strong>递推：</strong></p><ul><li>当word1[i - 1] 与 word2[j - 1]相同的时候</li><li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li></ul><p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];</p><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p><p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p><p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p><p>因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</p><p>这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i][j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i][j-1] + 1。</p><p><strong>dp数组如何初始化：</strong></p><p>从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。</p><p>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。</p><p>dp[0][j]的话同理</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/19ad34e5089f4f9bbcd6c86435f8d9c2.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/7cdce9d8f60b48e79f352db055469971.png" alt=""> java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word2.length();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>,Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（-）leetcode72-编辑距离"><a href="#（-）leetcode72-编辑距离" class="headerlink" title="（*****）leetcode72. 编辑距离"></a>（*****）leetcode72. 编辑距离</h3><p><a href="https://leetcode.cn/problems/edit-distance/description/" title="leetcode72. 编辑距离">leetcode72. 编辑距离</a></p><blockquote><p><strong>dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - 1] == word2[j - 1])</span><br><span class="line">    不操作</span><br><span class="line"><span class="keyword">if</span> (word1[i - 1] != word2[j - 1])</span><br><span class="line">    增</span><br><span class="line">    删</span><br><span class="line">    换</span><br></pre></td></tr></table></figure><p> <code>if (word1[i - 1] == word2[j - 1])</code> 那么说明不用任何编辑，<code>dp[i][j]</code> 就应该是 <code>dp[i - 1][j - 1]</code>，即<code>dp[i][j] = dp[i - 1][j - 1];</code></p><p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/e0fb61d7ba29424c914ce1448042d83b.png" alt=""></p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dp[i][j] = Math.min(insert, Math.min(delete, replace));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = word1.toCharArray(), c2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> c1.length, n = c2.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftUp</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">backup</span> <span class="operator">=</span> dp[j];</span><br><span class="line">                <span class="keyword">if</span> (c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = leftUp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = Math.min(leftUp, Math.min(dp[j], dp[j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                leftUp = backup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h3><p><img src="https://i-blog.csdnimg.cn/direct/62f8aab7d3604a71a391af377de2d4f0.png" alt=""></p><h3 id="怪盗基德的帽子"><a href="#怪盗基德的帽子" class="headerlink" title="怪盗基德的帽子"></a>怪盗基德的帽子</h3><p><img src="https://i-blog.csdnimg.cn/direct/16510be1060f48de83f2c47b76f25628.png" alt="">​</p><p> 本质：做了正反两次的LIS（最长上升子序列），进行比较大小，找出最长递增子序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line">        <span class="comment">//正向</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           f[i]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(w[j]&lt;w[i])&#123;</span><br><span class="line">                   f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//反向</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           f[i]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(w[j]&lt;w[i])&#123;</span><br><span class="line">                   f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h3><p><img src="https://i-blog.csdnimg.cn/direct/5a91eba5e28042bbad2d940aef4f220c.png" alt="">​</p><p>与上题一模一样，上题是单边找最大，这题是把两边加起来－1就可以，本质一样。</p><p><img src="https://i-blog.csdnimg.cn/direct/e7f393c4178d49feb69dfc8ca5012554.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合唱队形（洛谷）"><a href="#合唱队形（洛谷）" class="headerlink" title="合唱队形（洛谷）"></a>合唱队形（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P1091" title="[NOIP2004 提高组] 合唱队形 - 洛谷">[NOIP2004 提高组] 合唱队形 - 洛谷</a></p><p> 和登山一模一样，但是记得减一就好，模型就是：求前后的最大上升子序列，减去总共的就是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> k=n-res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友好城市（洛谷）"><a href="#友好城市（洛谷）" class="headerlink" title="友好城市（洛谷）"></a>友好城市（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P2782" title="友好城市 - 洛谷">友好城市 - 洛谷</a></p><p> <img src="https://i-blog.csdnimg.cn/direct/838bd7f152f4484ca7737d020a0a96e8.png" alt="">​</p><p> <img src="https://latex.csdn.net/eq?if%20%5Cquad%20index_1%3Cindex_2%2C%20val_1%3Cval_2%20%2Cthen%20%5C%3A%20OK" alt="if \quad index_1&lt;index_2, val_1&lt;val_2 ,then \: OK"></p><p>单调上升子序列，只有满足如上要求才可以</p><p>所以如果有一个序列排好序，则它一定是递增的，只要知道另一个对应的序列</p><p>的最长上升子序列，就是它最大的不重叠数量。</p><p>方法与思路：（举个栗子，图示）</p><p><img src="https://i-blog.csdnimg.cn/direct/99554a0536aa4e84ac1aa8f88fab466c.png" alt="">​</p><p> 用这样的想法我们能得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pii w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(w,w+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[j].second&lt;w[i].second)&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会发现如下的东西：</p><p><img src="https://i-blog.csdnimg.cn/direct/df64d4f3c36f4e01afd5365545fc58e7.png" alt="">​</p><p> 超时：</p><p>我刚刚利用动态规划复杂度为<img src="https://latex.csdn.net/eq?O%28N%5E2%29" alt="O(N^2)">，我们需要另外找一种方案去优化：</p><p>法1：</p><p>在我们每处理数列中的一位时，我们都要遍历数组找到值小于当前数中的f值的最大值，再用其加一作为现数字的值。如下，就是我们每一次记录的f【i】的值。</p><p><img src="https://i-blog.csdnimg.cn/direct/13e62770c80244c59383f98891808ed3.png" alt="">​</p><p>那么，如果我们维护一个取值集合，储存可能的最优解， 就可以优化算法的时间复杂度。</p><p>将一个数放入取值集合的条件是什么？如果两个数a、b ，当他们的f值相同，且a&lt;b,那么a对于后来的数来说，显然比b优。（运用了优先队列的思想）。例如：图中3,1 用1一定比用3好，因为更小。</p><p>我们用函数图像能更直观理解：</p><p><img src="https://i-blog.csdnimg.cn/direct/e485284933e14bfa9947f69052287ce8.png" alt="">​</p><p>所以我们只需要那么我们储存下对每一个f值来说的最小原数字值，在处理完新数字后将新数字与与其f值相同的数字比较大小，若小于则更新，若大于接在e数组后面。</p><p>每次我们都查找第一个比当前数大的位置在哪里，用lower_bound即可（二分法）。</p><p><img src="https://i-blog.csdnimg.cn/direct/df4ab32830814ccdac0a73d19f87fdae.png" alt="">​</p><p>用p做记录，记录尾插次数，也就是最长递增子序列，此时优化为了：<img src="https://latex.csdn.net/eq?O%28nlog_n%29" alt="O(nlog_n)"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pii w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii x,pii y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w,w+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[p]&lt;w[i].second) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            e[p]=w[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            e[<span class="built_in">lower_bound</span>(e,e+p,w[i].second)-e]=w[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会得到：</p><p><img src="https://i-blog.csdnimg.cn/direct/51132788070b4f73a28a6ae8285f194f.png" alt="">​</p><h3 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h3><p> <img src="https://i-blog.csdnimg.cn/direct/046762182ae340589a567ec599ec8043.png" alt="">​</p><p>只是在第一个最长上升子序列上面加上了w【i】 ，几乎没有什么变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>],f[<span class="number">1005</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i],f[j] + a[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题分析："><a href="#背包问题分析：" class="headerlink" title="背包问题分析："></a>背包问题分析：</h2><h3 id="01背包："><a href="#01背包：" class="headerlink" title="01背包："></a>01背包：</h3><p><img src="https://i-blog.csdnimg.cn/direct/b3c245b017944a528eb6ff894c1abc63.png" alt="">​</p><p><img src="https://i-blog.csdnimg.cn/direct/cea08c3d986e4813ad836065be610623.png" alt="">​</p><p>二维： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 滚动数组一维优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>],n,v,c[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> vv = v;vv &gt;= c[i];vv--)</span><br><span class="line">f[vv] = <span class="built_in">max</span>(f[vv],f[vv - c[i]] + w[i]);</span><br><span class="line">cout &lt;&lt; f[v];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h4><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/" title="Leetcode 416. 分割等和子集">Leetcode 416. 分割等和子集</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N=<span class="number">20001</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) res+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(res%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=res/<span class="number">2</span>;j;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i])&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j]=dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[res/<span class="number">2</span>]==res/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-1049-最后一块石头的重量-II"><a href="#Leetcode-1049-最后一块石头的重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头的重量 II"></a>Leetcode 1049. 最后一块石头的重量 II</h4><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/" title="Leetcode 1049. 最后一块石头的重量 II">Leetcode 1049. 最后一块石头的重量 II</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N=<span class="number">15001</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[N];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++) res+=stones[i];</span><br><span class="line">        <span class="type">int</span> r=res/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=r;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res-dp[r])-dp[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-494-目标和"><a href="#Leetcode-494-目标和" class="headerlink" title="Leetcode 494. 目标和"></a>Leetcode 494. 目标和</h4><p><a href="https://leetcode.cn/problems/target-sum/description/" title="Leetcode 494. 目标和">Leetcode 494. 目标和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) sum+=nums[i];</span><br><span class="line">        <span class="type">int</span> z=(sum+target);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="built_in">abs</span>(target)||z%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos=z/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(pos + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474.一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/" title="Leetcode 474.一和零">Leetcode 474.一和零</a></h4><p> <a href="https://leetcode.cn/problems/ones-and-zeroes/description/" title="Leetcode 474.一和零">Leetcode 474.一和零</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="type">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeroNum; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完全背包："><a href="#完全背包：" class="headerlink" title="完全背包："></a>完全背包：</h3><p><img src="https://i-blog.csdnimg.cn/direct/fb1fc89a9c1f4a9692cb69e20a696513.png" alt="">​</p><p>优化：</p><p><img src="https://i-blog.csdnimg.cn/direct/979fc6aaf49044b3bc9739faf198ebf6.png" alt="">​ <img src="https://i-blog.csdnimg.cn/direct/27e670c68bec4dadbc1177b9fc157c8c.png" alt="">​</p><blockquote><p>总结：</p><p>f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包</p><p>f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题</p></blockquote><p> 二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &lt;= j)</span><br><span class="line">                f[i][j] =<span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动数组1维优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>],n,v,c[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> vv = v;vv &gt;= c[i];vv--)</span><br><span class="line">f[vv] = <span class="built_in">max</span>(f[vv],f[vv - c[i]] + w[i]);</span><br><span class="line"><span class="comment">//这里要正序，你可以理解为：f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">//这里是i的f,而不是i-1的，所以要与01背包不同（i-1）则需要逆序</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[v];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：多重背包的遍历顺序</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p>for  i：物品</p><pre><code>  for j:背包大小</code></pre><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>for  j：背包大小</p><pre><code>  for i:物品</code></pre><p>为什么：第一个理解成固定一个物品，再遍历背包看是否能满足，第二个应该是固定一个背包空间，遍历物品看是否能满足。</p><p>例如背包大小为3，·物品有1,2</p><p>如果按照第一种方式：先看1，再加入2，只会有{1,2}这种</p><p>如果按照第一种方式：背包大小为0，背包大小为1，背包大小为2，只就有{1,2}，{2,1}这两种</p><p>所以：第一种求的是组合数，第二种求的是排列数。</p><p>518,377就是上述两种不一样的方法。</p></blockquote><h4 id="Leetcde-518-零钱兑换-II"><a href="#Leetcde-518-零钱兑换-II" class="headerlink" title="Leetcde 518. 零钱兑换 II"></a>Leetcde 518. 零钱兑换 II</h4><p><a href="https://leetcode.cn/problems/coin-change-ii/" title="Leetcde 518. 零钱兑换 II">Leetcde 518. 零钱兑换 II</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]+=dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-377-组合总数Ⅳ"><a href="#Leetcode-377-组合总数Ⅳ" class="headerlink" title="Leetcode 377.组合总数Ⅳ"></a>Leetcode 377.组合总数Ⅳ</h4><p><a href="https://leetcode.cn/problems/combination-sum-iv/description/" title="Leetcode 377.组合总数Ⅳ">Leetcode 377.组合总数Ⅳ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=nums[i]&amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]])</span><br><span class="line">                    dp[j]+=dp[j-nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-322-零钱兑换"><a href="#leetcode-322-零钱兑换" class="headerlink" title="leetcode 322.零钱兑换"></a>leetcode 322.零钱兑换</h4><p><a href="https://leetcode.cn/problems/coin-change/submissions/556660704/" title="322.零钱兑换">322.零钱兑换</a></p><p><img src="https://i-blog.csdnimg.cn/direct/8885a71b3d3041d584276ef96193276d.jpeg" alt="">​</p><p>主要在于递推公式，但是不同的是初始化要一个特别大的数字，然后dp[0]=0;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> INT_INF=<span class="number">1e9</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,INT_INF)</span></span>;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==INT_INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode279-完全平方数"><a href="#leetcode279-完全平方数" class="headerlink" title="leetcode279.完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/submissions/556666198/" title="leetcode279.完全平方数">leetcode279.完全平方数</a></h4><p> <a href="https://leetcode.cn/problems/perfect-squares/submissions/556666198/" title="279.完全平方数">279.完全平方数</a></p><p>我们抽象以下：</p><p><img src="https://latex.csdn.net/eq?x%3Da_1%5E2&plus;a_2%5E2&plus;a_3%5E2&plus;...&plus;a_n%5E2" alt="x=a_1^2+a_2^2+a_3^2+...+a_n^2"></p><p>那么立马就变成完全背包问题：</p><p> 物品就是：从1开始一直到100（数据范围），重量就是<img src="https://latex.csdn.net/eq?i%5E2" alt="i^2">，价值就是i，然后dp[j]表示，表示第j个数需要的最少的数据个数。</p><p>和上面那个题一模一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">pow</span>(i,<span class="number">2</span>);j&lt;=n;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-<span class="built_in">pow</span>(i,<span class="number">2</span>)]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode129-单词拆分"><a href="#leetcode129-单词拆分" class="headerlink" title="leetcode129.单词拆分"></a>leetcode129.单词拆分</h4><p><a href="https://leetcode.cn/problems/word-break/description/" title="129.单词拆分">129.单词拆分</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;<span class="comment">//为了find到截取的字符串</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">v</span><span class="params">(s.size()<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;  <span class="comment">//字符从0~i开始遍历，指针为i,背包大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;   <span class="comment">//i-j用来截取，只有当v[j]==1并且存在截取的子串时才可以</span></span><br><span class="line">            string sub=s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">                <span class="keyword">if</span>(v[j]&amp;&amp;wordSet.<span class="built_in">find</span>(sub)!=wordSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    v[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h3><h4 id="多重背包看做01背包"><a href="#多重背包看做01背包" class="headerlink" title="多重背包看做01背包"></a>多重背包看做01背包</h4><p><strong>这个思路就是把多重背包看成是01背包：</strong>  </p><p><img src="https://i-blog.csdnimg.cn/direct/8ac2dfb8d2314c0cbb2cceeb06379f19.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,vv,s[<span class="number">101</span>],v[<span class="number">101</span>],w[<span class="number">101</span>],dp[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; vv;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="comment">//遍历是第几个物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; s[i];j++)<span class="comment">//遍历第i个物品用了j遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = vv;k &gt;= v[i];k--)</span><br><span class="line"><span class="comment">//逆序，遍历从最大背包体积开始，背包大小为k是，向背包放物品。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[k] = <span class="built_in">max</span>(dp[k],dp[k - v[i]] + w[i]);<span class="comment">//递推公式，体积为k时，不选这个物品，就是继承之前的i-1的dp[k]，选这个物品，就是背包大小减去v[i]，加上w[i]的价值。</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[vv];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包二进制优化"><a href="#多重背包二进制优化" class="headerlink" title="多重背包二进制优化"></a>多重背包二进制优化</h4><p>二进制怎么表示这个10呢  <strong>10 = 1 + 2 + 4 + 3，再</strong>比如7 就可以用 1 + 2 + 4来表示，只需要枚举3次。这就是我们二进制优化的思想。</p><p>比如：第一件物品有v[i]=2（体积）,w[i]=3（价值）,s[i]=12（数量）；可以拆分为：4件如下图所示的物品：（其实本质还是01背包，只不过这时候我们合并了一下，让其装的更快了）</p><p><img src="https://i-blog.csdnimg.cn/direct/5ca14df2e84e46b88575bcc906d1ad2a.png" alt="">​</p><p><img src="https://i-blog.csdnimg.cn/direct/6da2d39d2d2e48d5bda15a6e58bf2fee.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2001</span>],n,V,v,w,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<span class="comment">//第i个物品，体积，价值，个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= s;k &lt;&lt;= <span class="number">1</span>)<span class="comment">// 以 k &lt;&lt;= 1 实际上是将 k 的值乘以 2。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = V;j &gt;= k*v;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*v]+k*w);<span class="comment">//把第i件多拆分成几件，再做01背包            &#125;</span></span><br><span class="line">            s -= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = V;j &gt;= s*v;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-s*v]+s*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h4><p><img src="https://i-blog.csdnimg.cn/direct/20ff0a9e87944a0c8cda69d98114f3f7.png" alt="">​</p><p> 本题题解来源：<a href="https://www.acwing.com/solution/content/53507/" title="AcWing 6. 多重背包问题 III【单调队列优化+图示】 - AcWing">AcWing 6. 多重背包问题 III【单调队列优化+图示】 - AcWing</a></p><p>按照完全背包的思路：我们列举如下：</p><p><img src="https://i-blog.csdnimg.cn/direct/750241a6c3644699b8b3aa039e6f9aa6.png" alt="">​</p><p>r表示j </p><p><img src="https://i-blog.csdnimg.cn/direct/ac046c2c569f4c49a0aba251274ea457.png" alt="">​</p><p>具体图示：</p><p><img src="https://i-blog.csdnimg.cn/direct/d922806b35db4606a7656b4970626cf0.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    时间复杂度的分析，我觉得通过代码很难看出来，</span></span><br><span class="line"><span class="comment">    可以通过它的计算过程以及它计算的大体次数来体会。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比如总体积为V = 10,某个物品对应v=3</span></span><br><span class="line"><span class="comment">    以一个物品为例，我们计算的时候，是把这个物品按照对v取余的结果来分类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    v&#x27; = 0是一类，这一类有 0, 3, 6, 9      (v&#x27;表示当前正在求的体积)</span></span><br><span class="line"><span class="comment">    v&#x27; = 1是一类，这一类有 1, 4, 7, 10</span></span><br><span class="line"><span class="comment">    v&#x27; = 2是一类，这一类有 2, 5, 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    我们通过单调队列优化，只是在每一类中进行优化(滑动窗口求最值)</span></span><br><span class="line"><span class="comment">    对于每个物品，我们都会求一遍v&#x27; = 0 ~ v&#x27; = 10，只是再求的过程中把它们分类了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一共n个物品，我们会对 物品1 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment">                       对 物品2 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment">                       ....</span></span><br><span class="line"><span class="comment">                       对 物品n 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总共实际求了 n * (v&#x27;的最大值)， 即 n*m次</span></span><br><span class="line"><span class="comment">    所以时间复杂度是O(n*m)的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20020</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], g[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;s);</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>;c &lt; v;c ++)&#123; <span class="comment">// 遍历余数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = c;j &lt;= m;j += v)&#123; <span class="comment">// 遍历余数为c这一类的 体积</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前层的f[j]  暂时等于 上一层的g[j]  相当于 f[i][j] = f[i-1][j];  也就是s = 0情况</span></span><br><span class="line">                f[j] = g[j]; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里一共有s+1个元素,s=0也算一个，所以这里不是j - s*v + 1</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; j - s*v &gt; q[hh]) hh ++; <span class="comment">// 队列存的是下标，也是体积 </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 队列中最大的(s!=0的其中一个)  和 s=0的进行比较</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt) f[j] = <span class="built_in">max</span>(f[j], g[q[hh]] + (j-q[hh])/v*w); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// q[tt]这个体积下的价值，再加上与j体积相差的体积数的价值，才能与g[j]进行对等比较   </span></span><br><span class="line">                <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; g[q[tt]] + (j - q[tt])/v*w &lt;= g[j]) tt --; </span><br><span class="line"></span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h3 id="leetcode089-打家劫舍"><a href="#leetcode089-打家劫舍" class="headerlink" title="leetcode089.打家劫舍"></a>leetcode089.打家劫舍</h3><p><a href="https://leetcode.cn/problems/Gu0c2T/" title="089.打家劫舍">089.打家劫舍</a></p><p>用普通线性dp：</p><p>从0~i家店铺最大收益：dp[i]=max(dp[i-1],dp[i-2]+nums[i]);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态机思路：</p><p>引入两个状态：  </p><p>f(i)————&gt;f(i,0)（未选择最后一个店铺）</p><p>|                                  </p><p>|</p><p>-—————-&gt;f(i,1)（选择最后一个店铺）</p><p><img src="https://i-blog.csdnimg.cn/direct/814b9e0b3c1b439d8fdc22ee6760412c.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/house-robber-ii/description/" title="213.打家劫舍2">213.打家劫舍2</a>（补充线性dp）</p><p>对打家劫舍1进行分类讨论，分为：选第一个，还是选最后一个，其他都是一模一样。分为0~n-2与1~n-1，两个部分，也就是考虑nums[0]，考虑nums[n-1]，这两个数的分类讨论。（因为选了0不能选n-1，选了n-1，不能选0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">robrange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[l]=nums[l],dp[l<span class="number">+1</span>]=<span class="built_in">max</span>(nums[l],nums[l<span class="number">+1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">+2</span>;i&lt;=r;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r];</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robrange</span>(nums,<span class="number">0</span>,n<span class="number">-2</span>),<span class="built_in">robrange</span>(nums,<span class="number">1</span>,n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买股票的最佳时机4"><a href="#leetcode买股票的最佳时机4" class="headerlink" title="leetcode买股票的最佳时机4"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" title="leetcode买股票的最佳时机4">leetcode买股票的最佳时机4</a></h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" title="买股票的最佳时机4">买股票的最佳时机4</a></p><p><img src="https://i-blog.csdnimg.cn/direct/768d8f15245f4acbab273a9ba996d550.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        <span class="comment">//dp[prices.size()+1][k+1][2];</span></span><br><span class="line">        <span class="comment">//考虑0次交易</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=prices.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][0][1]=-1e9;表示状态不合法</span></span><br><span class="line">        <span class="comment">//考虑有交易</span></span><br><span class="line">        <span class="comment">//dp[0][1][0]=-1e9;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) res=<span class="built_in">max</span>(res,dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在这个基础上，我们直接搞定前面的几道股票题：</p><h3 id="leetcode121-买卖股票的最佳时机"><a href="#leetcode121-买卖股票的最佳时机" class="headerlink" title="leetcode121. 买卖股票的最佳时机"></a>leetcode121. 买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" title="121. 买卖股票的最佳时机">121. 买卖股票的最佳时机</a></p><p>变化：</p><blockquote><p> dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]);<br>dp[i][1]=max(dp[i-1][1] , -prices[i]);//因为限定交易次数为1，只能交易1次</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , -prices[i]);<span class="comment">//因为限定交易次数为1，只能交易1次</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode122-买卖股票的最佳时机-2"><a href="#leetcode122-买卖股票的最佳时机-2" class="headerlink" title="leetcode122. 买卖股票的最佳时机 2"></a>leetcode122. 买卖股票的最佳时机 2</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" title="122. 买卖股票的最佳时机 II">122. 买卖股票的最佳时机 II</a></p><p>变化：</p><blockquote><p> dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]);<br>dp[i][1]=max(dp[i-1][1] , dp[i-1][0]-prices[i]);//无限交易次数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//无限交易次数</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode123-买卖股票的最佳时机-3"><a href="#leetcode123-买卖股票的最佳时机-3" class="headerlink" title="leetcode123. 买卖股票的最佳时机 3"></a>leetcode123. 买卖股票的最佳时机 3</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/" title="123. 买卖股票的最佳时机 III">123. 买卖股票的最佳时机 III</a></p><p>变化：</p><blockquote><p> int k=2;即可，其他均不变</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        <span class="comment">//dp[prices.size()+1][k+1][2];</span></span><br><span class="line">        <span class="comment">//考虑0次交易</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=prices.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][0][1]=-1e9;表示状态不合法</span></span><br><span class="line">        <span class="comment">//考虑有交易</span></span><br><span class="line">        <span class="comment">//dp[0][1][0]=-1e9;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) res=<span class="built_in">max</span>(res,dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买卖股票的最佳时机含冷冻期"><a href="#leetcode买卖股票的最佳时机含冷冻期" class="headerlink" title="leetcode买卖股票的最佳时机含冷冻期"></a>leetcode买卖股票的最佳时机含冷冻期</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" title="买卖股票的最佳时间含冷冻期">买卖股票的最佳时间含冷冻期</a></p><p> <img src="https://i-blog.csdnimg.cn/direct/065ce52db1824441a7093d0aacc51f07.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];<span class="comment">//第0天买入</span></span><br><span class="line">        <span class="comment">//dp[0][2]=-1e9;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买卖股票的最佳时机含手续费"><a href="#leetcode买卖股票的最佳时机含手续费" class="headerlink" title="leetcode买卖股票的最佳时机含手续费"></a>leetcode买卖股票的最佳时机含手续费</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" title="买卖股票的最佳时机含手续费">买卖股票的最佳时机含手续费</a></p><blockquote><p>与股票2完全一样，</p><p>dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]-fee) //卖出股票时完成一次交易，支付手续费<br>dp[i][1]=max(dp[i-1][1] , dp[i-1][0]-prices[i])</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//无限交易次数</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="leetcode-打家劫舍3"><a href="#leetcode-打家劫舍3" class="headerlink" title="leetcode 打家劫舍3"></a>leetcode 打家劫舍3</h3><p><a href="https://leetcode.cn/problems/house-robber-iii/description/" title="打家劫舍3">打家劫舍3</a></p><p>dp数组（这里写成PII）的含义：first记录不偷该节点所得到的的最大金钱，second记录偷该节点所得到的的最大金钱。</p><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        PII r=<span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="type">int</span> result=<span class="built_in">max</span>(r.first,r.second);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PII <span class="title">robTree</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            PII l=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            PII r=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="type">int</span> rob_yes=root-&gt;val+l.first+r.first;</span><br><span class="line">            <span class="type">int</span> rob_not=<span class="built_in">max</span>(l.second,l.first)+<span class="built_in">max</span>(r.first,r.second);<span class="comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span></span><br><span class="line">            <span class="keyword">return</span> &#123;rob_not,rob_yes&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode二叉树的直径"><a href="#leetcode二叉树的直径" class="headerlink" title="leetcode二叉树的直径"></a>leetcode二叉树的直径</h3><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/" title="二叉树的直径">二叉树的直径</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">find</span>(root);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">find</span>(root-&gt;left)<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">find</span>(root-&gt;right)<span class="number">+1</span>;</span><br><span class="line">        re=<span class="built_in">max</span>(re,l+r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode二叉树中的最大路径和"><a href="#leetcode二叉树中的最大路径和" class="headerlink" title="leetcode二叉树中的最大路径和"></a>leetcode二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/" title="二叉树中的最大路径和">二叉树中的最大路径和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> re=<span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">maxTreeReturnlrAndSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTreeReturnlrAndSum</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">maxTreeReturnlrAndSum</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">maxTreeReturnlrAndSum</span>(root-&gt;right);</span><br><span class="line">        re=<span class="built_in">max</span>(re,l+r+root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(l+root-&gt;val,r+root-&gt;val),<span class="number">0</span>);<span class="comment">//由于返回值会有负数，所以我们还需要和0，取一个最大值，因为如果是负数，我们可以选择不要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><h3 id="小国王"><a href="#小国王" class="headerlink" title="小国王"></a>小国王</h3><p><a href="https://blog.csdn.net/m0_64226820/article/details/126199603?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224A577738-06E0-411F-B41D-A1C6B261F777%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=4A577738-06E0-411F-B41D-A1C6B261F777&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126199603-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E7%8A%B6%E5%8E%8Bdp&amp;spm=1018.2226.3001.4187" title="状态压缩DP 图文详解（一）_状压dp-CSDN博客">状态压缩DP 图文详解（一）_状压dp-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  K = <span class="number">110</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line"><span class="type">int</span> cnt[M]; <span class="comment">//状态state[a]的国王个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];<span class="comment">//head[i] 里存储在第i行状态为state[a]的情况下，上一行状态可以取到的合法状态statep[b]</span></span><br><span class="line">LL f[N][K][M]; <span class="comment">//状态转移方程，存方案数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="comment">//同一行两个国王不能相邻</span></span><br><span class="line">        <span class="keyword">if</span>((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> state)</span> <span class="comment">//统计该状态下国王，即1的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += state &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//预处理所有合法状态 (对于这两个状态压缩有疑惑的，看看上面的图)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.<span class="built_in">push_back</span>(i); <span class="comment">//将合法方案存入state</span></span><br><span class="line">            cnt[i] = <span class="built_in">count</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//预处理所有合法状态的合法转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; state.<span class="built_in">size</span>();i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; state.<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b)) <span class="comment">//a &amp; b 指第i行和i-1行不能在同列有国王， check(a|b) == 1 指i和i -1行不能相互攻击到</span></span><br><span class="line">                head[i].<span class="built_in">push_back</span>(j);  <span class="comment">//head[i] 里存储在第i行状态为state[a]的情况下，上一行状态可以取到的合法状态statep[b]</span></span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//求方案数时，初始方案需要为1,因为全部空 也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i ++) <span class="comment">//枚举每一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j ++) <span class="comment">//国王数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>;a &lt; state.<span class="built_in">size</span>();a ++) <span class="comment">//枚举合法方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> b : head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c = cnt[state[a]];  <span class="comment">//状态state[a]的国王个数</span></span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= c)</span><br><span class="line">                        f[i][j][state[a]] += f[i - <span class="number">1</span>][j - c][state[b]]; <span class="comment">//f[i][state[a]], 在第i行状态为i时，所有i - 1行的状态数量</span></span><br><span class="line">                    <span class="comment">//因为state[a]和a呈映射关系，所也可以写成</span></span><br><span class="line">                    <span class="comment">//  f[i][j][a] += f[i - 1][j - c][b];</span></span><br><span class="line">                &#125;</span><br><span class="line">        cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//我们假设摆到n + 1行，并且另这一行状态为0,那么即得到我们想要的答案， </span></span><br><span class="line">    <span class="comment">//如果我们用f[n][m][]来获取答案，那么我们就要枚举最后一行的所有状态取最大值，来得到答案。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647. 回文子串"></a>leetcode 647. 回文子串</h3><p><a href="https://baijiahao.baidu.com/s?id=1801374813549433140&amp;wfr=spider&amp;for=pc" title="leetcode 647. 回文子串">leetcode 647. 回文子串</a></p><blockquote><p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 </p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li></ul><p><strong>遍历顺序：</strong></p><p><img src="https://i-blog.csdnimg.cn/direct/aaa7bfad9bb1431680974ca2d6404d88.png" alt=""></p><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</strong>。</p></blockquote><p> java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//一定要j&gt;i</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j) )&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想知道最长的回文串长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">         <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//一定要j&gt;i</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j) )&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j - i ==<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s.length();k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;s.length();l++)&#123;</span><br><span class="line">                    res=Math.max(res,dp[k][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindromic-substrings/solutions/379987/hui-wen-zi-chuan-by-leetcode-solution/" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p><p>其他方法|</p><h3 id="leetcode-516-最长回文子序列"><a href="#leetcode-516-最长回文子序列" class="headerlink" title="leetcode 516. 最长回文子序列"></a>leetcode 516. 最长回文子序列</h3><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/" title="leetcode 516. 最长回文子序列">leetcode 516. 最长回文子序列</a></p><blockquote><p><strong>dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</strong>。</p><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;</p><p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p><p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p><p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p><p>那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p><p><img src="https://i-blog.csdnimg.cn/direct/95ec8fff8e5649d6ac0cdfb5b27a9b26.png" alt=""></p><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2024/10/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/10/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>定义：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p></blockquote><p><strong>一个有N个点的图，边一定是大于等于N-1条的。图的最小生成树，就是在这些边中选择N-1条出来，连接所有的N个点。这N-1条边的边权之和是所有方案中最小的。</strong></p><p>通俗的来讲：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。</p><p>如果要求一个图的最小生成树，可以用prim和kruskal算法</p><h2 id="1-prim"><a href="#1-prim" class="headerlink" title="1.prim"></a>1.prim</h2><p>类似于dijkstra算法</p><blockquote><p>int dist[n],state[n],pre[n];<br>dist[1] = 0;<br>for(i : 1 ~ n)<br>{<br>    t &lt;- 没有连通起来，但是距离连通部分最近的点;<br>    state[t] = 1;<br>    更新 dist 和 pre;<br>}</p></blockquote><p>参考之前的代码，我们不难得到：（带注释）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>  res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j]&amp;&amp;(t == <span class="number">-1</span> || dis[t] &gt; dis[j]))&#123;</span><br><span class="line"><span class="comment">//j不在集合中，找到最小dis</span></span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;dis[t]==INF) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="comment">//i不是第一个点，如果最短的dis为INF，说明不联通，没有最短路，直接返回</span></span><br><span class="line">        res+=dis[t];<span class="comment">//累积求和</span></span><br><span class="line">        st[t]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],g[t][j]);</span><br><span class="line"><span class="comment">//与dijkstra不同，这里不需要dis[t]+g[t][j]应为我们是累加，而不是求每一个点到第一点的最短距离。    </span></span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//注意是无向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了之前的经验，我们直到，这里也可以用堆优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL ,LL &gt;PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">LL n,m,resmax;</span><br><span class="line">LL e[N],ne[N],w[N],idx=<span class="number">0</span>,h[N];</span><br><span class="line">LL res[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,LL ww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=ww,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(res,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> res);</span><br><span class="line">    res[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[t.second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.second]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t.second];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=e[i];</span><br><span class="line">            <span class="keyword">if</span>(res[k]&gt;w[i]&amp;&amp;!st[k])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k]=w[i];<span class="comment">//这一块不太一样</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;res[k],k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a,b,ww;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;ww;</span><br><span class="line">        <span class="built_in">add</span>(a,b,ww);</span><br><span class="line">        <span class="built_in">add</span>(b,a,ww);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        resmax=resmax+res[i];</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;resmax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-kruskal"><a href="#2-kruskal" class="headerlink" title="2.kruskal"></a>2.kruskal</h2><p>思路非常简单，算法实现类似于之前的并查集。</p><blockquote><p><strong>算法思路：</strong></p><p>将所有边按照权值的大小进行升序排序，然后从小到大一一判断。</p><p>如果这个边与之前选择的所有边不会组成回路，就选择这条边分；反之，舍去。</p><p>直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。</p><p>筛选出来的边和所有的顶点构成此连通网的最小生成树。</p><p><strong>判断是否会产生回路的方法为：使用并查集。</strong></p><p>在初始状态下给各个个顶点在不同的集合中。</p><p>遍历过程的每条边，判断这两个顶点的是否在一个集合中。</p><p>如果边上的这两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则要这条边。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    <span class="comment">//重载运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge&amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a,b=edges[i].b,w=edges[i].w;</span><br><span class="line">        <span class="type">int</span> ra=<span class="built_in">find</span>(a),rb=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(ra!=rb)&#123;</span><br><span class="line">            p[ra]=rb;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果重载运算符不理解可以换成：</p><p>bool cmp(struct Edge A, struct Edge B)<br>{<br>return A.w &lt; B.w;<br>}<br>然后sort里加个参数 ： sort(edges, edges + m,cmp);</p>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
